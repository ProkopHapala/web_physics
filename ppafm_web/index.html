<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>WebGL Probe-Particle AFM - Stage 1</title>
    <style>
      :root {
        --bg: #f8f9fb;
        --fg: #1e1f24;
        --muted: #5a6170;
        --accent: #2f7de1;
        --border: #d4d8e1;
        --pad: 2px;
        --radius: 4px;
        --font: 11px "Segoe UI", "Helvetica Neue", Arial, sans-serif;
      }
      * { box-sizing: border-box; }
      body {
        margin: 0;
        font: var(--font);
        background: var(--bg);
        color: var(--fg);
        height: 100vh;
        display: flex;
        flex-direction: row;
      }
      #container {
        flex: 0 0 512px; /* fixed-size square viewport */
        width: 512px;
        height: 512px;
        background: #fff;
        border-right: 1px solid var(--border);
      }
      #ui {
        flex: 0 0 640px; /* fixed-width sidebar */
        padding: var(--pad);
        box-sizing: border-box;
        overflow: auto;
        border-left: 1px solid var(--border);
      }
      textarea {
        width: 200%;
        height: 200px;
        padding: var(--pad);
        border: 1px solid var(--border);
        border-radius: var(--radius);
        background: #fff;
        color: var(--fg);
        font: var(--font);
      }
      input[type="number"], input[type="text"], input[type="file"] {
        width: 80px;
        padding: var(--pad);
        margin: 1px;
        border: 1px solid var(--border);
        border-radius: var(--radius);
        background: #fff;
        color: var(--fg);
        font: var(--font);
      }
      button {
        margin: 1px 0;
        padding: 2px 6px;
        border: 1px solid var(--border);
        border-radius: var(--radius);
        background: linear-gradient(#fff, #f1f3f7);
        color: var(--fg);
        font: var(--font);
        cursor: pointer;
      }
      button:hover { border-color: var(--accent); color: var(--accent); }
      .row { margin-bottom: 2px; }
      label { display: inline-block; width: 80px; margin: 1px 0; color: var(--muted); }
      a { color: var(--accent); }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r83/three.js"></script>
  </head>
  <body>
    <div id="container"></div>
    <div id="ui">
      <div class="row" style="font-size: 12px; line-height: 1.25; color: #ccc;">
        <strong>Tip:</strong> Run via <code>http://</code> not <code>file://</code> to avoid CORS blocking shader loads.
        For a quick local server run: <code>python3 -m http.server 8000</code> in this folder, then open
        <code>http://127.0.0.1:8000/ppafm_web/</code>.
        If WebGL is disabled, enable hardware acceleration in your browser settings and restart (Chrome/Firefox/Edge),
        then verify at <a href="https://get.webgl.org" target="_blank" rel="noopener">get.webgl.org</a>.
      </div>
      <div class="row"><strong>Probe-Particle AFM (Stage 1: atoms as blobs)</strong></div>
      <div class="row">
        <label for="fileXYZ">Load local .xyz</label>
        <input id="fileXYZ" type="file" accept=".xyz,text/plain" />
      </div>
      <div class="row">
        <label> Z plane     </label><input id="inpZ"          type="number" step="0.1" value="6.2" />
        <label> Scale       </label><input id="inpScale"      type="number" step="0.5" value="10.0" />
      </div>
      <div class="row">
        <label> Center X    </label><input id="inpCX"         type="number" step="0.5" value="0.0" />
        <label> Center Y    </label><input id="inpCY"         type="number" step="0.5" value="0.0" />
      </div>
      <div class="row">
        <label> Contrast    </label><input id="inpContrast"   type="number" step="0.1" value="10.0" />
      </div>
      <div class="row">
        <label> Auto-update </label><input id="chkAutoUpdate" type="checkbox" checked />
        <label> Animate     </label><input id="chkAnimate"    type="checkbox" />
      </div>
      <div class="row">
        <label> Center XY   </label><input id="chkCenterXY"   type="checkbox" checked />
        <label> Shift Z     </label><input id="chkShiftZ"     type="checkbox" checked />
      </div>
      <div class="row">
        <label> Probe Q     </label><input id="inpProbeQ"     type="number" step="0.01"   value="-0.05" />
        <label> Rpp         </label><input id="inpProbeR"     type="number" step="0.01"   value="1.6612" />
        <label> Epp         </label><input id="inpProbeE"     type="number" step="0.0001" value="0.009106" />
      </div>
      <div class="row">
        <label> k_lat       </label><input id="inpKLat"       type="number" step="0.1"    value="0.5" />
        <label> k_rad       </label><input id="inpKRad"       type="number" step="1"      value="20.0" />
        <label> R_tip       </label><input id="inpRTip"       type="number" step="0.1"    value="3.5" />
      </div>
      <div class="row">
        <label> Relax iters </label><input id="inpRelaxIters" type="number" step="1"      value="32" />
        <label> dt          </label><input id="inpDt"         type="number" step="0.01"   value="0.5" />
        <label> F2Conv      </label><input id="inpF2Conv"     type="number" step="1e-8"   value="1e-6" />
      </div>
      <div class="row">
        <label> Osc steps   </label><input id="inpOscSteps"   type="number" step="1"      value="8" />
        <label> dz          </label><input id="inpDz"         type="number" step="0.01"   value="0.1" />
        <label> Amp         </label><input id="inpOscAmp"     type="number" step="0.1"    value="0.8" />
      </div>
      <div class="row">
        <label> Pre-relax   </label><input id="inpPreRelax"   type="number" step="1"      value="16" />
        <label> Substeps    </label><input id="inpRelaxSub"   type="number" step="1"      value="4" />
        <label> Render (0/1/2/3)</label><input id="inpRender" type="number" step="1"      value="0" />
      </div>
      <div class="row">
        <label> Algo (0/1)</label><input id="inpAlgo"        type="number" step="1"      value="0" />
      </div>
      <div class="row">
        <button id="btnApplyXYZ">Apply XYZ below</button>
        <button id="btnUpdateView">Update view</button>
      </div>
      <div class="row">
        <label>XYZ input</label>
        <!-- <textarea id="txtXYZ" spellcheck="false">12

Br         3.26630        0.00100        0.00000     -0.1
Cl        -1.57610       -2.69890       -0.00010     -0.1
Cl        -1.57760        2.69800       -0.00020     -0.1
C          1.37620        0.00030        0.00000     -0.05
C          0.67830        1.20810        0.00000     -0.05
C          0.67910       -1.20800       -0.00010     -0.05
C         -0.71590       -1.20820        0.00000     -0.05
C         -0.71660        1.20780        0.00020     -0.05
C         -1.41360       -0.00030        0.00010     -0.05
H          1.22000        2.15150        0.00000     +0.2
H          1.22130       -2.15110       -0.00010     +0.2
H         -2.50150       -0.00060        0.00010     +0.2
</textarea> -->

        <textarea id="txtXYZ" spellcheck="false">
57		
			
H	18.104373	10.401761	2.369083
H	15.723386	14.788904	2.998967
H	18.222862	14.695479	2.815662
H	19.391609	12.53275	2.576687
H	12.527993	4.212183	2.905962
H	16.957029	6.57417	2.604585
H	16.844763	4.074362	2.696337
H	14.667275	2.908347	2.814978
H	6.363155	9.757266	2.388214
H	8.732031	5.35711	2.972512
H	6.232341	5.459763	2.796706
H	5.070068	7.629339	2.589743
H	11.921506	15.945094	2.920939
H	7.504387	13.564116	2.595464
H	7.606341	16.067155	2.672836
H	9.781073	17.239443	2.805498
C	15.158601	10.40057	2.504868
C	14.12512	12.351805	2.80396
C	16.190995	11.418522	2.53513
C	15.525435	12.647498	2.750762
C	17.593391	11.353726	2.49784
C	16.240749	13.848137	2.822221
C	18.303086	12.548239	2.612965
C	17.638784	13.77992	2.752133
C	12.54747	7.130026	2.764944
C	14.501576	8.177866	2.555203
C	13.5614	6.106163	2.728354
C	14.794848	6.772197	2.610055
C	13.489556	4.710452	2.800319
C	15.998517	6.057406	2.577722
C	14.684568	3.994891	2.761864
C	15.923931	4.655049	2.666489
C	9.307027	9.749219	2.509953
C	10.337373	7.795889	2.791581
C	8.272466	8.733226	2.536627
C	8.936036	7.50081	2.740277
C	6.871324	8.802721	2.508651
C	8.217295	6.30071	2.803211
C	6.15875	7.609611	2.617216
C	6.819033	6.37416	2.740556
C	11.915141	13.021115	2.7903
C	9.965566	11.970728	2.575298
C	10.898362	14.044258	2.753516
C	9.667415	13.375531	2.630581
C	10.963018	15.440743	2.815164
C	8.460624	14.084946	2.582506
C	9.766203	16.152496	2.761569
C	8.52855	15.488808	2.658654
N	13.204998	13.291637	2.865853
N	15.441647	9.103614	2.376948
N	11.258047	6.85734	2.844182
N	9.024472	11.047488	2.393733
N	13.918216	10.973349	2.660016
N	13.142926	8.392626	2.667018
N	10.546202	9.174504	2.657936
N	11.32322	11.757364	2.687684
Co	12.232819	10.07487	2.601853
</textarea>

      </div>

      <div class="row" style="margin-top:4px; border-top:1px solid var(--border); padding-top:2px; font-size:10px; line-height:1.25; color:var(--muted); max-width:420px;">
        <strong>Usage & physics</strong><br/>
        <strong>XYZ input:</strong> first line = number of atoms, then lines "Sym x y z [q]". Optional last column is atomic charge <code>q</code> (e).<br/>
        <strong>Probe:</strong> <code>Probe Q</code> is tip charge, <code>Rpp,Epp</code> are LJ parameters for the probe particle. Sample LJ is taken from element type and mixed with probe (LorentzBerthelot).<br/>
        <strong>Tip spring:</strong> <code>k_lat,k_rad,R_tip</code> define lateral and radial stiffness and equilibrium bond length; they control how strongly the CO-like particle bends and stretches.<br/>
        <strong>Relaxation:</strong> <code>Relax iters,dt,F2Conv</code> set maximum iterations, step and convergence threshold. <code>Osc steps,dz,Amp,Pre-relax,Substeps</code> control the adiabatic approach and df integration along the oscillation path.<br/>
        <strong>Render mode:</strong> 0 = frequency shift df (Giessibl convolution), 1 = relaxed vertical force Fz, 2 = residual |F| after relaxation, 3 = relative iteration count.<br/>
        <strong>Model:</strong> This WebGL demo implements the probe-particle AFM model where a flexible particle (e.g. CO) attached to the tip relaxes in the combined Morse+LJ+Coulomb field of sample atoms, reproducing high-resolution nc-AFM contrast.<br/>
        <strong>References:</strong>
        Hapala et al., <em>Mechanism of high-resolution STM/AFM imaging with functionalized tips</em>, Phys. Rev. B 90, 085421 (2014),
        <a href="https://doi.org/10.1103/PhysRevB.90.085421" target="_blank" rel="noopener">doi:10.1103/PhysRevB.90.085421</a>.<br/>
        Oinonen et al., <em>Advancing scanning probe microscopy simulations: A decade of development in probe-particle models</em>, Comput. Phys. Commun. 305, 109341 (2024),
        <a href="https://doi.org/10.1016/j.cpc.2024.109341" target="_blank" rel="noopener">doi:10.1016/j.cpc.2024.109341</a>.<br/>
        Code and related tools: <a href="https://github.com/Probe-Particle/PPSTM" target="_blank" rel="noopener">github.com/Probe-Particle/PPSTM</a>.
      </div>

      <div class="row" id="status"></div>
    </div>

    <script>
      var renderer, scene, camera, material, mesh;
      var animateEnabled = false; // animation OFF by default
      var autoUpdate     = true;  // auto-update ON by default
      var frameCounter   = 0;

      // Minimal LJ parameter table extracted from atomtypes.ini
      // Columns there: Rii, Eii, ???, Z, Symbol, ...
      // Here we only keep Rii (Å) and Eii (eV) for elements used in examples.
      var elementLJ = {
        H :  { R: 1.4870, E: 0.000681 },
        C :  { R: 1.9080, E: 0.003729 },
        N :  { R: 1.7800, E: 0.007372 },
        O :  { R: 1.6612, E: 0.009106 },
        Cl:  { R: 1.9480, E: 0.011491 },
        Br:  { R: 2.2200, E: 0.013876 }
      };
      // Molecule bounds in sample coordinates (after any Z-shift)
      var molBounds = {
        hasData: false,
        minX: 0.0, maxX: 0.0,
        minY: 0.0, maxY: 0.0,
        minZ: 0.0, maxZ: 0.0
      };

      var uniforms = {
        uResolution: { value: new THREE.Vector2() },
        uZPlane:     { value: 5.0 },
        uScale:      { value: 10.0 },
        uCenter:     { value: new THREE.Vector2(0.0, 0.0) },
        uContrast:   { value: 0.5 },
        uKLat:       { value: 0.5 },
        uKRad:       { value: 20.0 },
        uRtip:       { value: 4.0 },
        uRelaxIters: { value: 16 },
        uDt:         { value: 0.1 },
        uF2Conv:     { value: 1e-6 },
        uAlgo:       { value: 0 },   // 0 = basic Euler, 1 = quench
        uRenderMode: { value: 0 },   // 0 = df, 1 = Fz, 2 = residual |F|, 3 = iter count
        uOscSteps:   { value: 8 },
        uDz:         { value: 0.1 },
        uOscAmp:     { value: 0.8 },
        uPreRelax:   { value: 16 },
        uRelaxSub:   { value: 4 },
        uWeights:    { value: new Float32Array(32).fill(0.0) },
        uNumAtoms:   { value: 0 },
        uAtoms:      { value: [] },
        // Per-atom Morse+Coulomb parameters (R0,E0,Q,K)
        uREQK:       { value: [] }
      };

      function init() {
        if (location.protocol === 'file:') {
          setStatus('Warning: running from file:// — browsers block fetch() of PP_AFM_shader.glslf. Please serve via http:// (e.g., python3 -m http.server 8000).');
          console.warn('file:// detected; shader fetch will be blocked by CORS. Serve via http:// instead.');
        }
        var container = document.getElementById('container');
        scene = new THREE.Scene();
        camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 10);
        camera.position.z = 1;

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        container.appendChild(renderer.domElement);

        uniforms.uResolution.value.set(renderer.domElement.width, renderer.domElement.height);

        // Initialize uAtoms and uREQK with 256 dummy entries so three.js never sees undefined
        var maxAtoms = 256;
        var atomsInit = [];
        var reqkInit  = [];
        for (var i = 0; i < maxAtoms; i++) {
          atomsInit.push(new THREE.Vector4(1e9, 1e9, 1e9, 0.0));
          // (R0,E0,Q,K) dummy values
          reqkInit.push(new THREE.Vector4(3.0, 0.1, 0.0, 1.5));
        }
        uniforms.uAtoms.value = atomsInit;
        uniforms.uREQK.value  = reqkInit;

        fetch('PP_AFM_shader.glslf')
          .then(function (r) { return r.text(); })
          .then(function (fragSource) {
            material = new THREE.ShaderMaterial({
              uniforms: uniforms,
              vertexShader: [
                'varying vec2 vUv;',
                'void main() {',
                '  vUv = uv;',
                '  gl_Position = vec4(position, 1.0);',
                '}'
              ].join('\n'),
              fragmentShader: fragSource
            });

            var geom = new THREE.PlaneBufferGeometry(2, 2);
            mesh = new THREE.Mesh(geom, material);
            scene.add(mesh);

            // After shader + mesh are ready, initialize from default XYZ and inputs
            applyXYZ(document.getElementById('txtXYZ').value);
            updateViewFromInputs();

            // Start animation loop only if enabled
            if (animateEnabled) {
              animate();
            }
          })
          .catch(function (e) {
            setStatus('Error loading shader: ' + e);
          });

        window.addEventListener('resize', onWindowResize, false);
        document.getElementById('fileXYZ').addEventListener('change', function (e) {
          var file = e.target.files[0];
          if (!file) return;
          var reader = new FileReader();
          reader.onload = function (evt) {
            var txt = evt.target.result;
            document.getElementById('txtXYZ').value = txt;
            applyXYZ(txt);
            // Initialize uniforms from current inputs and render once
            updateViewFromInputs();
            setStatus('Loaded local file: ' + file.name);
          };
          reader.onerror = function (evt) {
            setStatus('Error reading local file: ' + evt.target.error);
          };
          reader.readAsText(file);
        });
        document.getElementById('btnApplyXYZ').addEventListener('click', function () {
          applyXYZ(document.getElementById('txtXYZ').value);
          // Re-read inputs and render using current parameter values
          updateViewFromInputs();
        });

        function updateViewFromInputs() {
          // Re-read numeric inputs and sanitize physical parameters on the JS side
          var z        = parseFloat(document.getElementById('inpZ').value);
          var scale    = parseFloat(document.getElementById('inpScale').value);
          var cxUser   = parseFloat(document.getElementById('inpCX').value);
          var cyUser   = parseFloat(document.getElementById('inpCY').value);
          var contrast = parseFloat(document.getElementById('inpContrast').value);
          var kLat     = parseFloat(document.getElementById('inpKLat').value);
          var kRad     = parseFloat(document.getElementById('inpKRad').value);
          var RTip     = parseFloat(document.getElementById('inpRTip').value);
          var relaxIt  = parseInt  (document.getElementById('inpRelaxIters').value, 10);
          var dt       = parseFloat(document.getElementById('inpDt').value);
          var algo     = parseInt  (document.getElementById('inpAlgo').value, 10);
          var renderM  = parseInt  (document.getElementById('inpRender').value, 10);
          var f2conv   = parseFloat(document.getElementById('inpF2Conv').value);
          var oscSteps = parseInt  (document.getElementById('inpOscSteps').value, 10);
          var dz       = parseFloat(document.getElementById('inpDz').value);
          var oscAmp   = parseFloat(document.getElementById('inpOscAmp').value);
          var preRelax = parseInt  (document.getElementById('inpPreRelax').value, 10);
          var relaxSub = parseInt  (document.getElementById('inpRelaxSub').value, 10);

          // Apply defaults if parsing failed
        //   if (!isFinite(z))        z        = 0.0;
        //   if (!isFinite(scale))    scale    = 10.0;
        //   if (!isFinite(cxUser))   cxUser   = 0.0;
        //   if (!isFinite(cyUser))   cyUser   = 0.0;
        //   if (!isFinite(contrast)) contrast = 0.5;
        //   if (!isFinite(kLat))     kLat     = 0.5;
        //   if (!isFinite(kRad))     kRad     = 20.0;
        //   if (!isFinite(RTip))     RTip     = 4.0;
        //   if (!isFinite(dt))       dt       = 0.1;
        //   if (!isFinite(relaxIt))  relaxIt  = 16;
        //   if (!isFinite(algo))     algo     = 0;
        //   if (!isFinite(renderM))  renderM  = 0;
        //   if (!isFinite(f2conv))   f2conv   = 1e-6;
        //   if (!isFinite(oscSteps)) oscSteps = 32;
        //   if (!isFinite(dz))       dz       = 0.1;
        //   if (!isFinite(oscAmp))   oscAmp   = oscSteps * dz * 0.5;
        //   if (!isFinite(preRelax)) preRelax = 16;
        //   if (!isFinite(relaxSub)) relaxSub = 4;

          // Physical constraints: all stiffnesses, dt and bond length must be positive
          var EPS_K   = 1e-6;
          var EPS_DT  = 1e-5;
          var EPS_LEN = 1e-4;
          if (kLat <= 0.0)   kLat   = EPS_K;
          if (kRad <= 0.0)   kRad   = EPS_K;
          if (RTip <= 0.0)   RTip   = EPS_LEN;
          if (dt   <= 0.0)   dt     = EPS_DT;
          if (relaxIt < 1)   relaxIt = 1;
          if (oscSteps < 1)  oscSteps = 1;
          if (oscSteps > 32) oscSteps = 32;
          if (dz <= 0.0)     dz = 0.01;
          if (oscAmp <= 0.0) oscAmp = oscSteps * dz * 0.5;
          if (preRelax < 0)  preRelax = 0;
          if (preRelax > 32) preRelax = 32;
          if (relaxSub < 1)  relaxSub = 1;
          if (relaxSub > 16) relaxSub = 16;

          // Keep Osc steps, dz, Amp mutually consistent based on the last edited field
          var active = document.activeElement ? document.activeElement.id : '';
          if (active === 'inpOscSteps' || active === 'inpDz') {
            // steps or dz changed -> recompute Amp = steps * dz
            oscAmp = oscSteps * dz;
            var ampInput = document.getElementById('inpOscAmp');
            if (ampInput) ampInput.value = oscAmp.toFixed(3);
          } else if (active === 'inpOscAmp') {
            // Amp changed -> recompute steps ≈ Amp/dz, then snap Amp back to steps*dz
            var estSteps = Math.round(oscAmp / dz);
            if (!(estSteps > 0)) estSteps = 1;
            if (estSteps > 32) estSteps = 32;
            oscSteps = estSteps;
            oscAmp   = oscSteps * dz;
            var stepsInput = document.getElementById('inpOscSteps');
            var ampInput2  = document.getElementById('inpOscAmp');
            if (stepsInput) stepsInput.value = oscSteps.toString();
            if (ampInput2)  ampInput2.value  = oscAmp.toFixed(3);
          }
          // Determine actual anchor Z from user-defined height above top-most atom
          var chkShiftZ   = document.getElementById('chkShiftZ');
          var shiftZOn    = chkShiftZ && chkShiftZ.checked;
          var zTop = 0.0;
          if (molBounds.hasData) {
            zTop = shiftZOn ? 0.0 : molBounds.maxZ;
          }
          uniforms.uZPlane.value = zTop + z;
          uniforms.uScale.value  = scale;

          // Center: either molecule center + user offsets, or absolute user coordinates
          var centerX = cxUser;
          var centerY = cyUser;
          var chkCenterXY = document.getElementById('chkCenterXY');
          var centerOn    = chkCenterXY && chkCenterXY.checked;
          if (centerOn && molBounds.hasData) {
            var cxMol = 0.5 * (molBounds.minX + molBounds.maxX);
            var cyMol = 0.5 * (molBounds.minY + molBounds.maxY);
            centerX = cxMol + cxUser;
            centerY = cyMol + cyUser;
          }
          uniforms.uCenter.value.set(centerX, centerY);
          uniforms.uContrast.value = contrast;
          uniforms.uKLat.value       = kLat / 16.02176634; // convert from N/m to eV/Å^2
          uniforms.uKRad.value       = kRad / 16.02176634; // convert from N/m to eV/Å^2
          uniforms.uRtip.value       = RTip;
          uniforms.uRelaxIters.value = relaxIt;
          uniforms.uDt.value         = dt;
          uniforms.uAlgo.value       = algo;
          uniforms.uRenderMode.value = renderM;
          uniforms.uF2Conv.value     = f2conv;
          uniforms.uOscSteps.value   = oscSteps;
          uniforms.uDz.value         = dz;
          uniforms.uOscAmp.value     = oscAmp;
          uniforms.uPreRelax.value   = preRelax;
          uniforms.uRelaxSub.value   = relaxSub;
          // Recompute Giessibl weights
          var weights = calculateGiessiblWeights(oscSteps, dz);
          var wArr = uniforms.uWeights.value;
          wArr.fill(0.0);
          for (var wi = 0; wi < oscSteps && wi < wArr.length; wi++) {
            wArr[wi] = weights[wi];
          }
          setStatus('Updated view parameters');
          renderOnce();
        }

        // Giessibl weights as in getDfWeight
        function calculateGiessiblWeights(nSteps, dz) {
          if (!(nSteps > 1)) return [];
          var x = [];
          for (var i = 0; i <= nSteps; i++) {
            x.push(-1 + 2 * (i / nSteps)); // bottom -> top
          }
          var y = x.map(function (v) { var vv = 1 - v*v; return (vv > 0) ? Math.sqrt(vv) : 0.0; });
          var dy = [];
          for (var i = 0; i < nSteps; i++) {
            dy.push((y[i+1] - y[i]) / (dz * nSteps));
          }
          var fpi = Math.pow(nSteps - 2, 2);
          var prefactor = -1 * (1 + fpi * (2/Math.PI)) / (fpi + 1);
          var weights = [];
          for (var i = 0; i < nSteps; i++) {
            weights.push(dy[nSteps - 1 - i] * prefactor); // reverse: top->bottom
          }
          return weights;
        }

        // Button still available for manual trigger
        document.getElementById('btnUpdateView').addEventListener('click', updateViewFromInputs);

        // Auto-update when basic view parameter inputs change (if enabled)
        ['inpZ', 'inpScale', 'inpCX', 'inpCY', 'inpContrast', 'inpKLat', 'inpKRad', 'inpRTip', 'inpRelaxIters', 'inpDt', 'inpAlgo', 'inpRender', 'inpF2Conv', 'inpOscSteps', 'inpDz', 'inpOscAmp', 'inpPreRelax', 'inpRelaxSub']
          .forEach(function (id) {
            var el = document.getElementById(id);
            if (!el) return;
            el.addEventListener('input', function () {
              if (autoUpdate) {
                updateViewFromInputs();
              }
            });
          });

        // Mouse wheel should behave like up/down arrows on numeric inputs
        function attachWheelIncrement(id) {
          var el = document.getElementById(id);
          if (!el) return;
          el.addEventListener('wheel', function (ev) {
            ev.preventDefault();
            var step = parseFloat(el.step) || 1.0;
            var v    = parseFloat(el.value) || 0.0;
            var dir  = (ev.deltaY > 0) ? -1.0 : 1.0; // wheel up -> increase
            el.value = (v + dir * step).toString();
            updateViewFromInputs();
          });
        }

        ['inpZ', 'inpScale', 'inpCX', 'inpCY', 'inpContrast', 'inpKLat', 'inpKRad', 'inpRTip', 'inpDt', 'inpAlgo', 'inpRender', 'inpF2Conv', 'inpOscSteps', 'inpDz', 'inpOscAmp', 'inpPreRelax', 'inpRelaxSub'].forEach(attachWheelIncrement);

        // Auto-update REQK when probe parameters change
        ['inpProbeQ', 'inpProbeR', 'inpProbeE'].forEach(function (id) {
          var el = document.getElementById(id);
          if (!el) return;
          el.addEventListener('input', function () {
            if (autoUpdate) {
              applyXYZ(document.getElementById('txtXYZ').value);
              updateViewFromInputs();
            }
          });
        });
        // Auto-apply XYZ text edits
        var txtXYZ = document.getElementById('txtXYZ');
        if (txtXYZ) {
          txtXYZ.addEventListener('input', function () {
            if (autoUpdate) {
              applyXYZ(txtXYZ.value);
              updateViewFromInputs();
            }
          });
        }

        // Checkboxes to control auto-update and animation
        var chkAutoUpdate = document.getElementById('chkAutoUpdate');
        var chkAnimate    = document.getElementById('chkAnimate');
        if (chkAutoUpdate) {
          chkAutoUpdate.addEventListener('change', function () {
            autoUpdate = !!chkAutoUpdate.checked;
            console.log('autoUpdate =', autoUpdate);
          });
        }
        if (chkAnimate) {
          chkAnimate.addEventListener('change', function () {
            animateEnabled = !!chkAnimate.checked;
            console.log('animateEnabled =', animateEnabled);
            if (animateEnabled) {
              // Start animation loop
              animate();
            }
          });
        }

      }

      function onWindowResize() {
        var container = document.getElementById('container');
        if (!renderer) return;
        renderer.setSize(container.clientWidth, container.clientHeight);
        uniforms.uResolution.value.set(renderer.domElement.width, renderer.domElement.height);
      }

      // Render a single frame (used both for on-demand updates and animation)
      function renderOnce() {
        if (!(renderer && scene && camera)) return;
        console.log('renderOnce: rendering frame');
        renderer.render(scene, camera);
      }

      function animate() {
        if (!animateEnabled) return; // stop loop when animation is disabled
        requestAnimationFrame(animate);
        frameCounter++;
        if ((frameCounter % 60) === 0) {
          console.log('animate loop frame', frameCounter, 'animateEnabled =', animateEnabled);
        }
        renderOnce();
      }

      function setStatus(msg) {
        document.getElementById('status').textContent = msg;
      }

      function loadXYZ(url) {
        fetch(url)
          .then(function (r) { return r.text(); })
          .then(function (txt) {
            document.getElementById('txtXYZ').value = txt;
            applyXYZ(txt);
            setStatus('Loaded ' + url);
          })
          .catch(function (e) {
            setStatus('Error loading ' + url + ': ' + e);
          });
      }

      function applyXYZ(text) {
        var lines = text.split(/\r?\n/).filter(function (l) { return l.trim().length > 0; });
        if (lines.length < 3) {
          setStatus('XYZ seems too short');
          console.log('applyXYZ: too short, lines.length =', lines.length);
          return;
        }
        var natoms = parseInt(lines[0]);
        if (!(natoms > 0)) {
          setStatus('XYZ header natoms is not > 0');
          console.log('applyXYZ: invalid natoms from header, lines[0]=', lines[0]);
          return;
        }

        // Support both XYZ formats:
        // 1) With comment line:      N, comment, N atom lines  -> lines.length >= natoms+2, atoms start at index 2
        // 2) Without comment line:   N, N atom lines           -> lines.length >= natoms+1, atoms start at index 1
        var atomStartIndex = 2;
        if (lines.length < natoms + 2) {
          if (lines.length >= natoms + 1) {
            atomStartIndex = 1;
          } else {
            setStatus('XYZ header inconsistent with number of lines');
            console.log('applyXYZ: inconsistent lengths, natoms =', natoms, 'lines.length =', lines.length);
            return;
          }
        }
        var atoms = [];
        var minX =  1e9, minY =  1e9, minZ =  1e9;
        var maxX = -1e9, maxY = -1e9, maxZ = -1e9;
        for (var i = 0; i < natoms; i++) {
          var parts = lines[atomStartIndex + i].trim().split(/\s+/);
          if (parts.length < 4) continue;
          var x = parseFloat(parts[1]);
          var y = parseFloat(parts[2]);
          var z = parseFloat(parts[3]);
          // atomic charge if provided (take first parsable token beyond xyz)
          var q = 0.0;
          for (var qi = 4; qi < parts.length; qi++) {
            var qtmp = parseFloat(parts[qi].replace(',', '.'));
            if (isFinite(qtmp)) { q = qtmp; break; }
          }
          atoms.push(new THREE.Vector4(x, y, z, q));
          if (x < minX) minX = x; if (x > maxX) maxX = x;
          if (y < minY) minY = y; if (y > maxY) maxY = y;
          if (z < minZ) minZ = z; if (z > maxZ) maxZ = z;
        }
        // Probe parameters from UI
        var qProbe = parseFloat(document.getElementById('inpProbeQ').value) || 0.05;
        var Rpp    = parseFloat(document.getElementById('inpProbeR').value) || 1.6612;   // O from atomtypes.ini
        var Epp    = parseFloat(document.getElementById('inpProbeE').value) || 0.009106; // O from atomtypes.ini

        // Build REQK per atom: (R0,E0,Q,K) using Lorentz-Berthelot mixing
        // Rij = Rpp + Rii, Eij = sqrt(Epp * Eii), Q = qProbe * q_atom
        var REQK = [];
        var K_default   = 1.5;
        for (var j = 0; j < atoms.length; j++) {
          var partsj = lines[atomStartIndex + j].trim().split(/\s+/);
          var sym = partsj[0];
          var lj  = elementLJ[sym] || elementLJ['C'];
          var Rii = lj.R;
          var Eii = lj.E;
          var R0  = Rpp + Rii;
          var E0  = Math.sqrt(Math.max(Epp,0.0) * Math.max(Eii,0.0));
          var qj  = atoms[j].w;
          var Qij = qProbe * qj;
          REQK.push(new THREE.Vector4(R0, E0, Qij, K_default));
        }

        // GLSL uses fixed-size arrays uAtoms[256] and uREQK[256], so pad
        var maxAtoms = 256;
        uniforms.uNumAtoms.value = Math.min(atoms.length, maxAtoms);
        if (atoms.length > maxAtoms) {
          atoms.length = maxAtoms;
          REQK.length = maxAtoms;
        }
        // Padding defaults for REQK (used for off-screen dummy atoms)
        var R0_pad = 3.0;
        var E0_pad = 0.1;
        while (atoms.length < maxAtoms) {
          atoms.push(new THREE.Vector4(1e9, 1e9, 1e9, 0.0));
          REQK.push(new THREE.Vector4(R0_pad, E0_pad, 0.0, K_default));
        }
        uniforms.uAtoms.value = atoms;
        uniforms.uREQK.value  = REQK;

        if (uniforms.uNumAtoms.value > 0) {
          console.log('applyXYZ/REQK: uNumAtoms =', uniforms.uNumAtoms.value,
                      'atom0 xyzq =', atoms[0].x, atoms[0].y, atoms[0].z, atoms[0].w,
                      'REQK0 =', REQK[0].x, REQK[0].y, REQK[0].z, REQK[0].w);
        }

        // Store molecule bounds; optional Z-shift (top-most atom to z=0) is handled via checkbox
        if (uniforms.uNumAtoms.value > 0) {
          var chkShiftZ = document.getElementById('chkShiftZ');
          var shiftZOn  = chkShiftZ && chkShiftZ.checked;
          var zShift    = shiftZOn ? maxZ : 0.0;

          // Apply Z-shift if requested and recompute bounds in shifted coordinates
          if (shiftZOn) {
            minZ -= zShift;
            maxZ -= zShift;
            for (var ia = 0; ia < atoms.length; ia++) {
              atoms[ia].z -= zShift;
            }
          }

          molBounds.hasData = true;
          molBounds.minX = minX;
          molBounds.maxX = maxX;
          molBounds.minY = minY;
          molBounds.maxY = maxY;
          molBounds.minZ = minZ;
          molBounds.maxZ = maxZ;
        }

        // Debug output
        if (uniforms.uNumAtoms.value > 0) {
          console.log('applyXYZ: uNumAtoms =', uniforms.uNumAtoms.value,
                      'first atom =', atoms[0].x, atoms[0].y, atoms[0].z,
                      'center =', uniforms.uCenter.value.x, uniforms.uCenter.value.y,
                      'zPlane =', uniforms.uZPlane.value, 'scale =', uniforms.uScale.value);
        } else {
          console.log('applyXYZ: no atoms parsed');
        }

        setStatus('Parsed ' + uniforms.uNumAtoms.value + ' atoms');
      }

      init();
    </script>
  </body>
</html>
