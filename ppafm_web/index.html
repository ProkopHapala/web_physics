<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>WebGL Probe-Particle AFM - Stage 1</title>
    <style>
      :root {
        --bg: #f8f9fb;
        --fg: #1e1f24;
        --muted: #5a6170;
        --accent: #2f7de1;
        --border: #d4d8e1;
        --pad: 1px;
        --radius: 4px;
        --font: 11px "Segoe UI", "Helvetica Neue", Arial, sans-serif;
      }
      * { box-sizing: border-box; }
      body {
        margin: 0;
        font: var(--font);
        background: var(--bg);
        color: var(--fg);
        height: 100vh;
        display: flex;
        flex-direction: row;
      }
      #container {
        flex: 0 0 512px; /* fixed-size square viewport */
        width: 512px;
        height: 512px;
        background: #fff;
        border-right: 1px solid var(--border);
        position: relative;
      }

      #overlay2d {
        position: absolute;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
      }
      #ui {
        flex: 0 0 480px; /* ~3/4 of the previous 640px */
        padding: var(--pad);
        box-sizing: border-box;
        overflow: auto;
        border-left: 1px solid var(--border);
      }
      textarea {
        width: 200%;
        height: 200px;
        margin: 2px 0;
        border: 1px solid var(--border);
        border-radius: var(--radius);
        padding: var(--pad);
        background: #fff;
        color: var(--fg);
        font: 11px/1.1 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      }
      input[type="number"], input[type="text"], input[type="file"] {
        width: 64px;
        padding: var(--pad);
        margin: 1px;
        border: 1px solid var(--border);
        border-radius: var(--radius);
        background: #fff;
        color: var(--fg);
        font: var(--font);
      }
      button {
        margin: 1px 0;
        padding: 2px 6px;
        border: 1px solid var(--border);
        border-radius: var(--radius);
        background: linear-gradient(#fff, #f1f3f7);
        color: var(--fg);
        font: var(--font);
        cursor: pointer;
      }
      button:hover { border-color: var(--accent); color: var(--accent); }
      .row { margin-bottom: 1px; }
      label { display: inline-block; width: 56px; margin: 1px 0; color: var(--muted); }
      a { color: var(--accent); }

      select {
        width: 130px;
      }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r83/three.js"></script>
  </head>
  <body>
    <div id="container"></div>
    <div id="ui">
      <div class="row" style="font-size: 12px; line-height: 1.25; color: #ccc;">
        <strong>Tip:</strong> Run via <code>http://</code> not <code>file://</code> to avoid CORS blocking shader loads.
        For a quick local server run: <code>python3 -m http.server 8000</code> in this folder, then open
        <code>http://127.0.0.1:8000/ppafm_web/</code>.
        If WebGL is disabled, enable hardware acceleration in your browser settings and restart (Chrome/Firefox/Edge),
        then verify at <a href="https://get.webgl.org" target="_blank" rel="noopener">get.webgl.org</a>.
      </div>
      <div class="row"><strong>Probe-Particle AFM (Stage 1: atoms as blobs)</strong></div>
      <fieldset style="border:1px solid var(--border); border-radius: var(--radius); padding: 4px; margin: 2px 0;">
        <legend style="padding:0 4px; color: var(--muted);">View</legend>
        <div class="row">
          <label> Z plane     </label><input id="inpZ"          type="number" step="0.1" value="6.2" />
          <label> Scale       </label><input id="inpScale"      type="number" step="0.5" value="10.0" />
        </div>
        <div class="row">
          <label> Center X    </label><input id="inpCX"         type="number" step="0.5" value="0.0" />
          <label> Center Y    </label><input id="inpCY"         type="number" step="0.5" value="0.0" />
        </div>
        <div class="row">
          <label> Contrast    </label><input id="inpContrast"   type="number" step="0.1" value="10.0" />
        </div>
        <div class="row">
          <label> Grid Å      </label><input id="inpGridPeriod" type="number" step="0.1" value="1.0" />
        </div>
        <div class="row">
          <label for="selRenderMode">Render mode</label>
          <select id="selRenderMode" style="padding: var(--pad); margin: 1px; border: 1px solid var(--border); border-radius: var(--radius); background: #fff; color: var(--fg); font: var(--font);">
            <option value="0">df (Giessibl)</option>
            <option value="1">Fz (relaxed)</option>
            <option value="2">|F| residual</option>
            <option value="3">Iterations (relative)</option>
            <option value="4">Deflection HSV (dxy)</option>
            <option value="5">Deflection checker (dxy)</option>
            <option value="6">Deflection grid (dxy)</option>
            <option value="7">Fz + deflection grid</option>
          </select>
        </div>
        <div class="row">
          <label> Auto-update </label><input id="chkAutoUpdate" type="checkbox" checked />
          <label> Animate     </label><input id="chkAnimate"    type="checkbox" />
        </div>
        <div class="row">
          <label> Show atoms  </label><input id="chkShowAtoms" type="checkbox" checked />
        </div>
        <div class="row">
          <label for="selAtomLabel">Atom labels</label>
          <select id="selAtomLabel" style="padding: var(--pad); margin: 1px; border: 1px solid var(--border); border-radius: var(--radius); background: #fff; color: var(--fg); font: var(--font);">
            <option value="0">none</option>
            <option value="1">atom id</option>
            <option value="2">symbol</option>
            <option value="3">charge</option>
            <option value="4">z</option>
          </select>
        </div>
        <div class="row">
          <label> Center XY   </label><input id="chkCenterXY"   type="checkbox" checked />
          <label> Shift Z     </label><input id="chkShiftZ"     type="checkbox" checked />
        </div>
      </fieldset>

      <fieldset style="border:1px solid var(--border); border-radius: var(--radius); padding: 4px; margin: 2px 0;">
        <legend style="padding:0 4px; color: var(--muted);">Probe params</legend>
        <div class="row">
          <label for="selProbePreset">Preset</label>
          <select id="selProbePreset" style="padding: var(--pad); margin: 1px; border: 1px solid var(--border); border-radius: var(--radius); background: #fff; color: var(--fg); font: var(--font);">
            <option value="">(custom)</option>
            <option value="CO">CO</option>
            <option value="Xe">Xe</option>
            <option value="Cl">Cl</option>
          </select>
        </div>
        <div class="row">
          <label> Q           </label><input id="inpProbeQ"     type="number" step="0.01"   value="-0.05" />
          <label> Pz          </label><input id="inpTipPz"     type="number" step="0.01"   value="0.0" />
          <label> Qzz         </label><input id="inpTipQzz"    type="number" step="0.01"   value="0.0" />
        </div>
        <div class="row">
          <label> Rpp         </label><input id="inpProbeR"     type="number" step="0.01"   value="1.6612" />
          <label> Epp         </label><input id="inpProbeE"     type="number" step="0.0001" value="0.009106" />
        </div>
      </fieldset>

      <fieldset style="border:1px solid var(--border); border-radius: var(--radius); padding: 4px; margin: 2px 0;">
        <legend style="padding:0 4px; color: var(--muted);">Stiffness</legend>
        <div class="row">
          <label> k_lat       </label><input id="inpKLat"       type="number" step="0.1"    value="0.5" />
          <label> k_rad       </label><input id="inpKRad"       type="number" step="1"      value="20.0" />
          <label> R_tip       </label><input id="inpRTip"       type="number" step="0.1"    value="3.5" />
        </div>
      </fieldset>

      <fieldset style="border:1px solid var(--border); border-radius: var(--radius); padding: 4px; margin: 2px 0;">
        <legend style="padding:0 4px; color: var(--muted);">F → df</legend>
        <div class="row">
          <label> Osc steps   </label><input id="inpOscSteps"   type="number" step="1"      value="8" />
          <label> dz          </label><input id="inpDz"         type="number" step="0.01"   value="0.1" />
          <label> Amp         </label><input id="inpOscAmp"     type="number" step="0.1"    value="0.8" />
        </div>
      </fieldset>

      <details id="detailsAdvanced" style="border:1px solid var(--border); border-radius: var(--radius); padding: 4px; margin: 2px 0;">
        <summary style="color: var(--muted); cursor: pointer;">Advanced</summary>
        <div class="row">
          <label> Relax iters </label><input id="inpRelaxIters" type="number" step="1"      value="32" />
          <label> dt          </label><input id="inpDt"         type="number" step="0.01"   value="0.5" />
          <label> F2Conv      </label><input id="inpF2Conv"     type="number" step="1e-8"   value="1e-6" />
        </div>
        <div class="row">
          <label> Pre-relax   </label><input id="inpPreRelax"   type="number" step="1"      value="16" />
          <label> Substeps    </label><input id="inpRelaxSub"   type="number" step="1"      value="4" />
          <label> Algo (0/1)</label><input id="inpAlgo"        type="number" step="1"      value="0" />
        </div>
      </details>
      <div class="row">
        <button id="btnApplyXYZ">Apply XYZ below</button>
        <button id="btnUpdateView">Update view</button>
      </div>
      <div class="row">
        <label>XYZ input</label>
        <!-- <textarea id="txtXYZ" spellcheck="false">12

Br         3.26630        0.00100        0.00000     -0.1
Cl        -1.57610       -2.69890       -0.00010     -0.1
Cl        -1.57760        2.69800       -0.00020     -0.1
C          1.37620        0.00030        0.00000     -0.05
C          0.67830        1.20810        0.00000     -0.05
C          0.67910       -1.20800       -0.00010     -0.05
C         -0.71590       -1.20820        0.00000     -0.05
C         -0.71660        1.20780        0.00020     -0.05
C         -1.41360       -0.00030        0.00010     -0.05
H          1.22000        2.15150        0.00000     +0.2
H          1.22130       -2.15110       -0.00010     +0.2
H         -2.50150       -0.00060        0.00010     +0.2
</textarea> -->

        <div class="row" style="margin-top:2px;">
          <label for="selMolecule">Example .xyz</label>
          <select id="selMolecule" style="padding: var(--pad); margin: 1px; border: 1px solid var(--border); border-radius: var(--radius); background: #fff; color: var(--fg); font: var(--font);">
            <option value="">(select molecule)</option>
          </select>
          <label for="fileXYZ" style="width:auto;">Load local</label>
          <input id="fileXYZ" type="file" accept=".xyz,text/plain" style="width: 180px;" />
          <button id="btnSaveXYZ">Save</button>
        </div>

        <div class="row" style="margin-top:2px;">
          <label style="width:160px;">Geometry tools</label>
          <button id="btnGeomShiftZ">Shift Z→0</button>
          <button id="btnGeomFlattenZ">Flatten Z</button>
          <button id="btnGeomPCA">Align PCA</button>
        </div>

        <textarea id="txtXYZ" spellcheck="false">
57		
			
H	18.104373	10.401761	2.369083
H	15.723386	14.788904	2.998967
H	18.222862	14.695479	2.815662
H	19.391609	12.53275	2.576687
H	12.527993	4.212183	2.905962
H	16.957029	6.57417	2.604585
H	16.844763	4.074362	2.696337
H	14.667275	2.908347	2.814978
H	6.363155	9.757266	2.388214
H	8.732031	5.35711	2.972512
H	6.232341	5.459763	2.796706
H	5.070068	7.629339	2.589743
H	11.921506	15.945094	2.920939
H	7.504387	13.564116	2.595464
H	7.606341	16.067155	2.672836
H	9.781073	17.239443	2.805498
C	15.158601	10.40057	2.504868
C	14.12512	12.351805	2.80396
C	16.190995	11.418522	2.53513
C	15.525435	12.647498	2.750762
C	17.593391	11.353726	2.49784
C	16.240749	13.848137	2.822221
C	18.303086	12.548239	2.612965
C	17.638784	13.77992	2.752133
C	12.54747	7.130026	2.764944
C	14.501576	8.177866	2.555203
C	13.5614	6.106163	2.728354
C	14.794848	6.772197	2.610055
C	13.489556	4.710452	2.800319
C	15.998517	6.057406	2.577722
C	14.684568	3.994891	2.761864
C	15.923931	4.655049	2.666489
C	9.307027	9.749219	2.509953
C	10.337373	7.795889	2.791581
C	8.272466	8.733226	2.536627
C	8.936036	7.50081	2.740277
C	6.871324	8.802721	2.508651
C	8.217295	6.30071	2.803211
C	6.15875	7.609611	2.617216
C	6.819033	6.37416	2.740556
C	11.915141	13.021115	2.7903
C	9.965566	11.970728	2.575298
C	10.898362	14.044258	2.753516
C	9.667415	13.375531	2.630581
C	10.963018	15.440743	2.815164
C	8.460624	14.084946	2.582506
C	9.766203	16.152496	2.761569
C	8.52855	15.488808	2.658654
N	13.204998	13.291637	2.865853
N	15.441647	9.103614	2.376948
N	11.258047	6.85734	2.844182
N	9.024472	11.047488	2.393733
N	13.918216	10.973349	2.660016
N	13.142926	8.392626	2.667018
N	10.546202	9.174504	2.657936
N	11.32322	11.757364	2.687684
Co	12.232819	10.07487	2.601853
</textarea>

        <div class="row" style="margin-top:2px;">
          <label style="width:160px;">Atom LJ params (R,E)</label>
        </div>
        <div class="row" style="margin-top:2px;">
          <label style="width:160px;">Params file</label>
          <input id="fileAtomParams" type="file" accept=".ini,.txt,text/plain" style="width: 180px;" />
          <button id="btnSaveAtomParams">Save</button>
        </div>
        <textarea id="txtAtomParams" spellcheck="false" style="width: 200%; height: 140px;">H  1.4870 0.000681
C  1.9080 0.003729
N  1.7800 0.007372
O  1.6612 0.009106
Cl 1.9480 0.011491
Br 2.2200 0.013876
</textarea>

      </div>

      <div class="row" style="margin-top:4px; border-top:1px solid var(--border); padding-top:2px; font-size:10px; line-height:1.25; color:var(--muted); max-width:420px;">
        <strong>Usage & physics</strong><br/>
        <strong>XYZ input:</strong> first line = number of atoms, then lines "Sym x y z [q]". Optional last column is atomic charge <code>q</code> (e).<br/>
        <strong>Probe:</strong> <code>Probe Q</code> is tip charge, <code>Rpp,Epp</code> are LJ parameters for the probe particle. Sample LJ is taken from element type and mixed with probe (LorentzBerthelot).<br/>
        <strong>Tip spring:</strong> <code>k_lat,k_rad,R_tip</code> define lateral and radial stiffness and equilibrium bond length; they control how strongly the CO-like particle bends and stretches.<br/>
        <strong>Relaxation:</strong> <code>Relax iters,dt,F2Conv</code> set maximum iterations, step and convergence threshold. <code>Osc steps,dz,Amp,Pre-relax,Substeps</code> control the adiabatic approach and df integration along the oscillation path.<br/>
        <strong>Render mode:</strong> 0 = frequency shift df (Giessibl convolution), 1 = relaxed vertical force Fz, 2 = residual |F| after relaxation, 3 = relative iteration count.<br/>
        <strong>Model:</strong> This WebGL demo implements the probe-particle AFM model where a flexible particle (e.g. CO) attached to the tip relaxes in the combined Morse+LJ+Coulomb field of sample atoms, reproducing high-resolution nc-AFM contrast.<br/>
        <strong>References:</strong>
        Hapala et al., <em>Mechanism of high-resolution STM/AFM imaging with functionalized tips</em>, Phys. Rev. B 90, 085421 (2014),
        <a href="https://doi.org/10.1103/PhysRevB.90.085421" target="_blank" rel="noopener">doi:10.1103/PhysRevB.90.085421</a>.<br/>
        Oinonen et al., <em>Advancing scanning probe microscopy simulations: A decade of development in probe-particle models</em>, Comput. Phys. Commun. 305, 109341 (2024),
        <a href="https://doi.org/10.1016/j.cpc.2024.109341" target="_blank" rel="noopener">doi:10.1016/j.cpc.2024.109341</a>.<br/>
        Code and related tools: <a href="https://github.com/Probe-Particle/PPSTM" target="_blank" rel="noopener">github.com/Probe-Particle/PPSTM</a>.
      </div>

      <div class="row" id="status"></div>
    </div>

    <script>
      var renderer, scene, camera, material, mesh;
      var overlayCanvas, overlayCtx;
      var animateEnabled = false; // animation OFF by default
      var autoUpdate     = true;  // auto-update ON by default
      var frameCounter   = 0;

      // Raw atom list for JS overlay (un-padded, in sample coordinates)
      var atomsJS = [];

      // Element parameters loaded from common_resources/atomtypes.ini (R, E, optional color)
      var elementLJ = {};
      // Molecule bounds in sample coordinates (after any Z-shift)
      var molBounds = {
        hasData: false,
        minX: 0.0, maxX: 0.0,
        minY: 0.0, maxY: 0.0,
        minZ: 0.0, maxZ: 0.0
      };

      var uniforms = {
        uResolution: { value: new THREE.Vector2() },
        uZPlane:     { value: 5.0 },
        uScale:      { value: 10.0 },
        uCenter:     { value: new THREE.Vector2(0.0, 0.0) },
        uContrast:   { value: 0.5 },
        uGridPeriod: { value: 1.0 },
        uKLat:       { value: 0.5 },
        uKRad:       { value: 20.0 },
        uRtip:       { value: 4.0 },
        uRelaxIters: { value: 16 },
        uDt:         { value: 0.1 },
        uF2Conv:     { value: 1e-6 },
        uAlgo:       { value: 0 },   // 0 = basic Euler, 1 = quench
        uRenderMode: { value: 0 },   // 0 = df, 1 = Fz, 2 = residual |F|, 3 = iter count
        uOscSteps:   { value: 8 },
        uDz:         { value: 0.1 },
        uOscAmp:     { value: 0.8 },
        uPreRelax:   { value: 16 },
        uRelaxSub:   { value: 4 },
        uWeights:    { value: new Float32Array(32).fill(0.0) },
        uNumAtoms:   { value: 0 },
        uAtoms:      { value: [] },
        // Per-atom Morse+Coulomb parameters (R0,E0,Q,K)
        uREQK:       { value: [] }
        ,
        // Tip axial multipoles for electrostatics (monopole charge, dipole pz, quadrupole qzz)
        uTipQ:       { value: 0.0 },
        uTipPz:      { value: 0.0 },
        uTipQzz:     { value: 0.0 }
      };

      function init() {
        if (location.protocol === 'file:') {
          setStatus('Warning: running from file:// — browsers block fetch() of PP_AFM_shader.glslf. Please serve via http:// (e.g., python3 -m http.server 8000).');
          console.warn('file:// detected; shader fetch will be blocked by CORS. Serve via http:// instead.');
        }

        function parseXYZText(text) {
          var rawLines = text.split(/\r?\n/);
          // Keep original line count but ignore completely empty lines for structure detection
          var lines = rawLines.filter(function (l) { return l.trim().length > 0; });
          if (lines.length < 2) throw new Error('XYZ too short');
          var natoms = parseInt(lines[0], 10);
          if (!(natoms > 0)) throw new Error('XYZ header natoms is not > 0');
          var atomStartIndex = 2;
          var comment = '';
          if (lines.length < natoms + 2) {
            if (lines.length >= natoms + 1) {
              atomStartIndex = 1;
            } else {
              throw new Error('XYZ header inconsistent with number of lines');
            }
          } else {
            comment = lines[1];
          }
          var atoms = [];
          for (var i = 0; i < natoms; i++) {
            var L = lines[atomStartIndex + i];
            if (!L) throw new Error('Missing atom line ' + (i + 1));
            var parts = L.trim().split(/\s+/);
            if (parts.length < 4) throw new Error('Atom line ' + (i + 1) + ' has < 4 columns');
            var sym = parts[0];
            var x = parseFloat(parts[1]);
            var y = parseFloat(parts[2]);
            var z = parseFloat(parts[3]);
            if (!isFinite(x) || !isFinite(y) || !isFinite(z)) throw new Error('Atom line ' + (i + 1) + ' has non-numeric xyz');
            var q = null;
            for (var k = 4; k < parts.length; k++) {
              var qt = parseFloat(parts[k].replace(',', '.'));
              if (isFinite(qt)) { q = qt; break; }
            }
            atoms.push({ sym: sym, x: x, y: y, z: z, q: q });
          }
          return { natoms: natoms, comment: comment, hasComment: (atomStartIndex === 2), atoms: atoms };
        }

        function formatXYZ(obj) {
          var out = [];
          out.push(String(obj.atoms.length));
          if (obj.hasComment) out.push(obj.comment || '');
          for (var i = 0; i < obj.atoms.length; i++) {
            var a = obj.atoms[i];
            var line = a.sym + '\t' + a.x.toFixed(6) + '\t' + a.y.toFixed(6) + '\t' + a.z.toFixed(6);
            if (a.q !== null && isFinite(a.q)) line += '\t' + a.q.toFixed(6);
            out.push(line);
          }
          out.push('');
          return out.join('\n');
        }

        function geomApplyAndRender(newXYZText) {
          var ta = document.getElementById('txtXYZ');
          ta.value = newXYZText;
          // If we baked in a geometric shift, ensure we don't double-shift in applyXYZ
          var chkShiftZ = document.getElementById('chkShiftZ');
          if (chkShiftZ) chkShiftZ.checked = false;
          applyXYZ(newXYZText);
          updateViewFromInputs();
        }

        function geomShiftZToTop() {
          var txt = document.getElementById('txtXYZ').value;
          var xyz = parseXYZText(txt);
          var maxZ = -1e99;
          for (var i = 0; i < xyz.atoms.length; i++) if (xyz.atoms[i].z > maxZ) maxZ = xyz.atoms[i].z;
          for (var i = 0; i < xyz.atoms.length; i++) xyz.atoms[i].z -= maxZ;
          geomApplyAndRender(formatXYZ(xyz));
          setStatus('Geometry: shifted so top atom is at z=0');
        }

        function geomFlattenZ() {
          var txt = document.getElementById('txtXYZ').value;
          var xyz = parseXYZText(txt);
          for (var i = 0; i < xyz.atoms.length; i++) xyz.atoms[i].z = 0.0;
          geomApplyAndRender(formatXYZ(xyz));
          setStatus('Geometry: flattened (all z=0)');
        }

        function jacobiEigenSym3(A) {
          // A is 3x3 symmetric array [[a00,a01,a02],[a01,a11,a12],[a02,a12,a22]]
          // Returns { evals:[l0,l1,l2], evecs:[[...],[...],[...]] } where evecs columns are eigenvectors
          var V = [[1,0,0],[0,1,0],[0,0,1]];
          function rot(p, q) {
            if (Math.abs(A[p][q]) < 1e-15) return;
            var app = A[p][p], aqq = A[q][q], apq = A[p][q];
            var tau = (aqq - app) / (2.0 * apq);
            var t = (tau >= 0) ? (1.0 / (tau + Math.sqrt(1 + tau*tau))) : (-1.0 / (-tau + Math.sqrt(1 + tau*tau)));
            var c = 1.0 / Math.sqrt(1 + t*t);
            var s = t * c;
            // Update A
            A[p][p] = app - t * apq;
            A[q][q] = aqq + t * apq;
            A[p][q] = 0.0; A[q][p] = 0.0;
            for (var r = 0; r < 3; r++) {
              if (r === p || r === q) continue;
              var arp = A[r][p];
              var arq = A[r][q];
              A[r][p] = arp * c - arq * s;
              A[p][r] = A[r][p];
              A[r][q] = arq * c + arp * s;
              A[q][r] = A[r][q];
            }
            // Update V
            for (var r = 0; r < 3; r++) {
              var vrp = V[r][p];
              var vrq = V[r][q];
              V[r][p] = vrp * c - vrq * s;
              V[r][q] = vrq * c + vrp * s;
            }
          }
          for (var it = 0; it < 32; it++) {
            // Find largest off-diagonal
            var p = 0, q = 1;
            var m01 = Math.abs(A[0][1]);
            var m02 = Math.abs(A[0][2]);
            var m12 = Math.abs(A[1][2]);
            if (m02 > m01 && m02 > m12) { p = 0; q = 2; }
            else if (m12 > m01 && m12 > m02) { p = 1; q = 2; }
            var maxOff = Math.max(m01, m02, m12);
            if (maxOff < 1e-12) break;
            rot(p, q);
          }
          return { evals: [A[0][0], A[1][1], A[2][2]], evecs: V };
        }

        function geomAlignPCA() {
          var txt = document.getElementById('txtXYZ').value;
          var xyz = parseXYZText(txt);
          var n = xyz.atoms.length;
          if (n < 2) throw new Error('Need >= 2 atoms for PCA');
          // center
          var mx = 0, my = 0, mz = 0;
          for (var i = 0; i < n; i++) { mx += xyz.atoms[i].x; my += xyz.atoms[i].y; mz += xyz.atoms[i].z; }
          mx /= n; my /= n; mz /= n;
          // covariance
          var c00=0,c01=0,c02=0,c11=0,c12=0,c22=0;
          for (var i = 0; i < n; i++) {
            var dx = xyz.atoms[i].x - mx;
            var dy = xyz.atoms[i].y - my;
            var dz = xyz.atoms[i].z - mz;
            c00 += dx*dx; c01 += dx*dy; c02 += dx*dz;
            c11 += dy*dy; c12 += dy*dz;
            c22 += dz*dz;
          }
          var A = [[c00,c01,c02],[c01,c11,c12],[c02,c12,c22]];
          var eig = jacobiEigenSym3(A);
          // sort indices by eigenvalue ascending (smallest variance -> normal)
          var idx = [0,1,2];
          idx.sort(function (i, j) { return eig.evals[i] - eig.evals[j]; });
          var iz = idx[0], ix = idx[2], iy = idx[1];
          // Build rotation matrix R whose rows are target basis vectors (x,y,z) in original coords
          // eig.evecs is V with columns as eigenvectors; take column k as [V[0][k],V[1][k],V[2][k]]
          function col(k){ return [eig.evecs[0][k], eig.evecs[1][k], eig.evecs[2][k]]; }
          var ex = col(ix), ey = col(iy), ez = col(iz);
          // Ensure right-handed: ex x ey should point roughly ez
          var cx = ex[1]*ey[2]-ex[2]*ey[1];
          var cy = ex[2]*ey[0]-ex[0]*ey[2];
          var cz = ex[0]*ey[1]-ex[1]*ey[0];
          var dot = cx*ez[0] + cy*ez[1] + cz*ez[2];
          if (dot < 0) { ey[0]*=-1; ey[1]*=-1; ey[2]*=-1; }
          // Apply rotation: [x',y',z'] = [ex;ey;ez] * (r - mean)
          for (var i = 0; i < n; i++) {
            var dx = xyz.atoms[i].x - mx;
            var dy = xyz.atoms[i].y - my;
            var dz = xyz.atoms[i].z - mz;
            var xp = ex[0]*dx + ex[1]*dy + ex[2]*dz;
            var yp = ey[0]*dx + ey[1]*dy + ey[2]*dz;
            var zp = ez[0]*dx + ez[1]*dy + ez[2]*dz;
            xyz.atoms[i].x = xp;
            xyz.atoms[i].y = yp;
            xyz.atoms[i].z = zp;
          }
          geomApplyAndRender(formatXYZ(xyz));
          setStatus('Geometry: aligned by PCA (principal axes)');
        }

        function parseAtomParams(text) {
          // Format: "Sym R E [#RRGGBB]" per line; allow commas, comments (# ...), blank lines.
          // Returns a new map {Sym:{R,E,color}, ...}. Fails loudly on malformed lines.
          var out = {};
          var lines = text.split(/\r?\n/);
          for (var i = 0; i < lines.length; i++) {
            var line = lines[i];
            if (!line) continue;
            var clean = line.replace(/#.*/, '').trim();
            if (!clean) continue;
            var parts = clean.split(/\s+/);
            if (parts.length < 3) throw new Error('Atom params line ' + (i+1) + ' needs 3 columns: Sym R E');
            var sym = parts[0];
            var R = parseFloat(parts[1].replace(',', '.'));
            var E = parseFloat(parts[2].replace(',', '.'));
            if (!isFinite(R) || !isFinite(E)) throw new Error('Atom params line ' + (i+1) + ' has non-numeric R/E');
            var col = null;
            for (var k = 3; k < parts.length; k++) {
              if (/^#[0-9a-fA-F]{6}$/.test(parts[k])) { col = parts[k]; break; }
            }
            out[sym] = { R: R, E: E, color: col };
          }
          return out;
        }

        function parseAtomtypesIni(text) {
          // Expected columns: R E Z Sym [#RRGGBB]
          // Allows whitespace/tabs; ignores blank lines.
          var out = {};
          var lines = text.split(/\r?\n/);
          for (var i = 0; i < lines.length; i++) {
            var L = lines[i].trim();
            if (!L) continue;
            // allow full-line comments
            if (L[0] === '#') continue;
            var parts = L.split(/\s+/);
            if (parts.length < 4) continue;
            var R = parseFloat(parts[0].replace(',', '.'));
            var E = parseFloat(parts[1].replace(',', '.'));
            var sym = parts[3];
            if (!isFinite(R) || !isFinite(E) || !sym) continue;
            var col = null;
            for (var k = 4; k < parts.length; k++) {
              if (/^#[0-9a-fA-F]{6}$/.test(parts[k])) { col = parts[k]; break; }
            }
            out[sym] = { R: R, E: E, color: col };
          }
          return out;
        }

        function atomParamsToText(map) {
          var syms = Object.keys(map);
          syms.sort(function (a, b) { return a.localeCompare(b); });
          var out = [];
          for (var i = 0; i < syms.length; i++) {
            var s = syms[i];
            var it = map[s];
            var line = s + '  ' + Number(it.R).toFixed(6) + '  ' + Number(it.E).toFixed(9);
            if (it.color) line += '  ' + it.color;
            out.push(line);
          }
          out.push('');
          return out.join('\n');
        }

        function updateElementLJFromTextarea() {
          var ta = document.getElementById('txtAtomParams');
          if (!ta) return;
          var parsed = parseAtomParams(ta.value);
          elementLJ = parsed;
          if (uniforms && uniforms.uNumAtoms && uniforms.uNumAtoms.value > 0) {
            applyXYZ(document.getElementById('txtXYZ').value);
            updateViewFromInputs();
          }
        }

        // Initialize elementLJ from textarea if present
        try {
          updateElementLJFromTextarea();
        } catch (e) {
          setStatus('Error parsing Atom LJ params: ' + e);
        }

        // Load defaults from common_resources/atomtypes.ini (overwrites textarea + elementLJ)
        function loadDefaultAtomtypes() {
          var urlA = '../common_resources/atomtypes.ini';
          var urlB = 'atomtypes.ini';
          return fetch(urlA).then(function (r) {
            if (!r.ok) throw new Error('HTTP ' + r.status + ' for ' + urlA);
            return r.text();
          }).catch(function () {
            return fetch(urlB).then(function (r2) {
              if (!r2.ok) throw new Error('HTTP ' + r2.status + ' for ' + urlB);
              return r2.text();
            });
          }).then(function (txt) {
            var parsed = parseAtomtypesIni(txt);
            if (!Object.keys(parsed).length) throw new Error('No entries parsed from atomtypes.ini');
            elementLJ = parsed;
            var ta = document.getElementById('txtAtomParams');
            if (ta) ta.value = atomParamsToText(parsed);
            if (uniforms && uniforms.uNumAtoms && uniforms.uNumAtoms.value > 0) {
              applyXYZ(document.getElementById('txtXYZ').value);
              updateViewFromInputs();
            }
            setStatus('Loaded atom params: atomtypes.ini');
          }).catch(function (e) {
            setStatus('Cannot load atomtypes.ini: ' + e);
          });
        }

        loadDefaultAtomtypes();

        // Load/save of atom parameter text
        var fileAtomParams = document.getElementById('fileAtomParams');
        if (fileAtomParams) {
          fileAtomParams.addEventListener('change', function (e) {
            var file = e.target.files[0];
            if (!file) return;
            var reader = new FileReader();
            reader.onload = function (evt) {
              var txt = evt.target.result;
              var ta = document.getElementById('txtAtomParams');
              if (ta) ta.value = txt;
              try {
                updateElementLJFromTextarea();
                setStatus('Loaded atom params: ' + file.name);
              } catch (err) {
                setStatus('Error parsing atom params: ' + err);
                throw err;
              }
            };
            reader.readAsText(file);
          });
        }

        function saveAtomParamsText() {
          var ta = document.getElementById('txtAtomParams');
          var txt = (ta && ta.value) ? ta.value : '';
          if (!txt.trim()) { setStatus('Nothing to save (Atom params textarea is empty)'); return; }
          var blob = new Blob([txt], { type: 'text/plain' });
          var url = URL.createObjectURL(blob);
          var a = document.createElement('a');
          a.href = url;
          a.download = 'atomtypes.ini';
          document.body.appendChild(a);
          a.click();
          a.remove();
          setTimeout(function () { URL.revokeObjectURL(url); }, 0);
          setStatus('Saved: atomtypes.ini');
        }

        var btnSaveAtomParams = document.getElementById('btnSaveAtomParams');
        if (btnSaveAtomParams) btnSaveAtomParams.addEventListener('click', saveAtomParamsText);

        // Probe presets
        function applyProbePreset(name) {
          if (!name) return;
          var qEl = document.getElementById('inpProbeQ');
          var rEl = document.getElementById('inpProbeR');
          var eEl = document.getElementById('inpProbeE');
          var pzEl = document.getElementById('inpTipPz');
          var qzzEl = document.getElementById('inpTipQzz');
          if (!(qEl && rEl && eEl && pzEl && qzzEl)) return;

          // Default multipoles
          var Q = 0.0, Pz = 0.0, Qzz = 0.0;
          var symForLJ = name;
          if      (name === 'CO') { symForLJ = 'O';  Qzz = -0.2; } 
          else if (name === 'Xe') { symForLJ = 'Xe'; Q   = +0.1; } 
          else if (name === 'Cl') { symForLJ = 'Cl'; Q   = -0.15; }
          var lj = elementLJ[symForLJ];
          if (lj) {
            rEl.value = String(lj.R);
            eEl.value = String(lj.E);
          }
          qEl.value = String(Q);
          pzEl.value = String(Pz);
          qzzEl.value = String(Qzz);

          applyXYZ(document.getElementById('txtXYZ').value);
          updateViewFromInputs();
          setStatus('Probe preset: ' + name);
        }

        var selProbePreset = document.getElementById('selProbePreset');
        if (selProbePreset) {
          selProbePreset.addEventListener('change', function () {
            applyProbePreset(selProbePreset.value);
          });
        }

        // Auto-update element LJ parameters
        var txtAtomParams = document.getElementById('txtAtomParams');
        if (txtAtomParams) {
          txtAtomParams.addEventListener('input', function () {
            if (!autoUpdate) return;
            try {
              updateElementLJFromTextarea();
              setStatus('Updated Atom LJ params');
            } catch (e) {
              setStatus('Error parsing Atom LJ params: ' + e);
            }
          });
        }

        var container = document.getElementById('container');
        scene = new THREE.Scene();
        camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 10);
        camera.position.z = 1;

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        container.appendChild(renderer.domElement);

        // 2D overlay canvas on top of WebGL
        overlayCanvas = document.getElementById('overlay2d');
        if (!overlayCanvas) {
          overlayCanvas = document.createElement('canvas');
          overlayCanvas.id = 'overlay2d';
        }
        overlayCanvas.width  = renderer.domElement.width;
        overlayCanvas.height = renderer.domElement.height;
        container.appendChild(overlayCanvas);
        overlayCanvas.style.zIndex = '10';
        overlayCtx = overlayCanvas.getContext('2d');

        uniforms.uResolution.value.set(renderer.domElement.width, renderer.domElement.height);

        // Initialize uAtoms and uREQK with 256 dummy entries so three.js never sees undefined
        var maxAtoms = 256;
        var atomsInit = [];
        var reqkInit  = [];
        for (var i = 0; i < maxAtoms; i++) {
          atomsInit.push(new THREE.Vector4(1e9, 1e9, 1e9, 0.0));
          // (R0,E0,Q,K) dummy values
          reqkInit.push(new THREE.Vector4(3.0, 0.1, 0.0, 1.5));
        }
        uniforms.uAtoms.value = atomsInit;
        uniforms.uREQK.value  = reqkInit;

        fetch('PP_AFM_shader.glslf')
          .then(function (r) { return r.text(); })
          .then(function (fragSource) {
            material = new THREE.ShaderMaterial({
              uniforms: uniforms,
              vertexShader: [
                'varying vec2 vUv;',
                'void main() {',
                '  vUv = uv;',
                '  gl_Position = vec4(position, 1.0);',
                '}'
              ].join('\n'),
              fragmentShader: fragSource
            });

            var geom = new THREE.PlaneBufferGeometry(2, 2);
            mesh = new THREE.Mesh(geom, material);
            scene.add(mesh);

            // After shader + mesh are ready, initialize from default XYZ and inputs
            applyXYZ(document.getElementById('txtXYZ').value);
            updateViewFromInputs();

            // Start animation loop only if enabled
            if (animateEnabled) {
              animate();
            }
          })
          .catch(function (e) {
            setStatus('Error loading shader: ' + e);
          });

        window.addEventListener('resize', onWindowResize, false);
        document.getElementById('fileXYZ').addEventListener('change', function (e) {
          var file = e.target.files[0];
          if (!file) return;
          var reader = new FileReader();
          reader.onload = function (evt) {
            var txt = evt.target.result;
            document.getElementById('txtXYZ').value = txt;
            applyXYZ(txt);
            // Initialize uniforms from current inputs and render once
            updateViewFromInputs();
            setStatus('Loaded local file: ' + file.name);
          };
          reader.onerror = function (evt) {
            setStatus('Error reading local file: ' + evt.target.error);
          };
          reader.readAsText(file);
        });
        document.getElementById('btnApplyXYZ').addEventListener('click', function () {
          applyXYZ(document.getElementById('txtXYZ').value);
          // Re-read inputs and render using current parameter values
          updateViewFromInputs();
        });

        var btnGeomShiftZ = document.getElementById('btnGeomShiftZ');
        if (btnGeomShiftZ) {
          btnGeomShiftZ.addEventListener('click', function () {
            try { geomShiftZToTop(); } catch (e) { setStatus('Geometry Shift Z error: ' + e); throw e; }
          });
        }
        var btnGeomFlattenZ = document.getElementById('btnGeomFlattenZ');
        if (btnGeomFlattenZ) {
          btnGeomFlattenZ.addEventListener('click', function () {
            try { geomFlattenZ(); } catch (e) { setStatus('Geometry Flatten error: ' + e); throw e; }
          });
        }
        var btnGeomPCA = document.getElementById('btnGeomPCA');
        if (btnGeomPCA) {
          btnGeomPCA.addEventListener('click', function () {
            try { geomAlignPCA(); } catch (e) { setStatus('Geometry PCA error: ' + e); throw e; }
          });
        }

        function parseXYZLinksFromDirectoryListing(htmlText) {
          // Works with simple directory listings (e.g. python -m http.server).
          // We intentionally fail loudly if no listing is present.
          var re = /href\s*=\s*"([^"]+\.xyz)"/gi;
          var out = [];
          var m;
          while ((m = re.exec(htmlText)) !== null) {
            var href = m[1];
            var fname = href.split('/').pop().split('?')[0].split('#')[0];
            if (!fname) continue;
            if (out.indexOf(fname) < 0) out.push(fname);
          }
          out.sort(function (a, b) { return a.localeCompare(b); });
          return out;
        }

        function populateMoleculeSelect() {
          var sel = document.getElementById('selMolecule');
          if (!sel) return;
          var baseA = 'molecules/';
          var baseB = '../common_resources/molecules/';
          var fallbackFiles = [
            'adenine-thymine.xyz',
            'BPBA.xyz',
            'DBTH.xyz',
            'formic_dimer.xyz',
            'guanine-cytosine.xyz',
            'pentacene.xyz',
            'porphirin.xyz',
            'PTCDA.xyz',
            'pyridine.xyz',
            'pyrrol.xyz'
          ];
          function tryList(base1, base2) {
            return fetch(base1).then(function (r) {
              if (!r.ok) throw new Error('HTTP ' + r.status + ' for ' + base1);
              return r.text();
            }).then(function (htmlText) {
              return { base: base1, files: parseXYZLinksFromDirectoryListing(htmlText) };
            }).catch(function () {
              return fetch(base2).then(function (r2) {
                if (!r2.ok) throw new Error('HTTP ' + r2.status + ' for ' + base2);
                return r2.text();
              }).then(function (htmlText2) {
                return { base: base2, files: parseXYZLinksFromDirectoryListing(htmlText2) };
              });
            });
          }
          tryList(baseA, baseB).then(function (res) {
            if (!res.files.length) throw new Error('No .xyz links found in directory listing: ' + res.base);
            sel.dataset.base = res.base;
            // Keep the first placeholder option, drop everything else
            while (sel.options.length > 1) sel.remove(1);
            res.files.forEach(function (fname) {
              var opt = document.createElement('option');
              opt.value = fname;
              opt.textContent = fname;
              sel.appendChild(opt);
            });
            setStatus('Found ' + res.files.length + ' example molecules in ' + res.base);
          }).catch(function (e) {
            sel.dataset.base = baseB;
            while (sel.options.length > 1) sel.remove(1);
            fallbackFiles.forEach(function (fname) {
              var opt = document.createElement('option');
              opt.value = fname;
              opt.textContent = fname;
              sel.appendChild(opt);
            });
            setStatus('Cannot list example molecules (no directory listing?). Using built-in list from ' + baseB + '  ' + e);
          });
        }

        function loadExampleMolecule(fname) {
          if (!fname) return;
          var sel = document.getElementById('selMolecule');
          var base0 = (sel && sel.dataset && sel.dataset.base) ? sel.dataset.base : 'molecules/';
          var bases = [base0, '../common_resources/molecules/', 'molecules/'];
          function tryFetch(i) {
            if (i >= bases.length) throw new Error('All bases failed for ' + fname);
            var url = bases[i] + fname;
            return fetch(url).then(function (r) {
              if (!r.ok) throw new Error('HTTP ' + r.status + ' for ' + url);
              return r.text();
            }).catch(function () {
              return tryFetch(i + 1);
            });
          }
          tryFetch(0).then(function (txt) {
            var ta = document.getElementById('txtXYZ');
            ta.value = txt;
            applyXYZ(txt);
            updateViewFromInputs();
            setStatus('Loaded example: ' + fname);
          }).catch(function (e) {
            setStatus('Error loading example ' + fname + ': ' + e);
          });
        }

        function saveXYZText() {
          var ta = document.getElementById('txtXYZ');
          var txt = (ta && ta.value) ? ta.value : '';
          if (!txt.trim()) {
            setStatus('Nothing to save (XYZ textarea is empty)');
            return;
          }
          var sel = document.getElementById('selMolecule');
          var fname = (sel && sel.value) ? sel.value : 'molecule.xyz';
          if (!/\.xyz$/i.test(fname)) fname += '.xyz';
          var blob = new Blob([txt], { type: 'text/plain' });
          var url = URL.createObjectURL(blob);
          var a = document.createElement('a');
          a.href = url;
          a.download = fname;
          document.body.appendChild(a);
          a.click();
          a.remove();
          setTimeout(function () { URL.revokeObjectURL(url); }, 0);
          setStatus('Saved: ' + fname);
        }

        var selMol = document.getElementById('selMolecule');
        if (selMol) {
          selMol.addEventListener('change', function () {
            if (autoUpdate) loadExampleMolecule(selMol.value);
          });
        }
        var btnSave = document.getElementById('btnSaveXYZ');
        if (btnSave) {
          btnSave.addEventListener('click', saveXYZText);
        }

        populateMoleculeSelect();

        function updateViewFromInputs() {
          // Re-read numeric inputs and sanitize physical parameters on the JS side
          var z        = parseFloat(document.getElementById('inpZ').value);
          var scale    = parseFloat(document.getElementById('inpScale').value);
          var cxUser   = parseFloat(document.getElementById('inpCX').value);
          var cyUser   = parseFloat(document.getElementById('inpCY').value);
          var contrast = parseFloat(document.getElementById('inpContrast').value);
          var gridPer  = parseFloat(document.getElementById('inpGridPeriod').value);
          var tipQ     = parseFloat(document.getElementById('inpProbeQ').value);
          var tipPz    = parseFloat(document.getElementById('inpTipPz').value);
          var tipQzz   = parseFloat(document.getElementById('inpTipQzz').value);
          var kLat     = parseFloat(document.getElementById('inpKLat').value);
          var kRad     = parseFloat(document.getElementById('inpKRad').value);
          var RTip     = parseFloat(document.getElementById('inpRTip').value);
          var relaxIt  = parseInt  (document.getElementById('inpRelaxIters').value, 10);
          var dt       = parseFloat(document.getElementById('inpDt').value);
          var algo     = parseInt  (document.getElementById('inpAlgo').value, 10);
          var selRender = document.getElementById('selRenderMode');
          var renderM  = parseInt((selRender && selRender.value) ? selRender.value : '0', 10);
          var f2conv   = parseFloat(document.getElementById('inpF2Conv').value);
          var oscSteps = parseInt  (document.getElementById('inpOscSteps').value, 10);
          var dz       = parseFloat(document.getElementById('inpDz').value);
          var oscAmp   = parseFloat(document.getElementById('inpOscAmp').value);
          var preRelax = parseInt  (document.getElementById('inpPreRelax').value, 10);
          var relaxSub = parseInt  (document.getElementById('inpRelaxSub').value, 10);

          // Apply defaults if parsing failed
        //   if (!isFinite(z))        z        = 0.0;
        //   if (!isFinite(scale))    scale    = 10.0;
        //   if (!isFinite(cxUser))   cxUser   = 0.0;
        //   if (!isFinite(cyUser))   cyUser   = 0.0;
        //   if (!isFinite(contrast)) contrast = 0.5;
        //   if (!isFinite(kLat))     kLat     = 0.5;
        //   if (!isFinite(kRad))     kRad     = 20.0;
        //   if (!isFinite(RTip))     RTip     = 4.0;
        //   if (!isFinite(dt))       dt       = 0.1;
        //   if (!isFinite(relaxIt))  relaxIt  = 16;
        //   if (!isFinite(algo))     algo     = 0;
        //   if (!isFinite(renderM))  renderM  = 0;
        //   if (!isFinite(f2conv))   f2conv   = 1e-6;
        //   if (!isFinite(oscSteps)) oscSteps = 32;
        //   if (!isFinite(dz))       dz       = 0.1;
        //   if (!isFinite(oscAmp))   oscAmp   = oscSteps * dz * 0.5;
        //   if (!isFinite(preRelax)) preRelax = 16;
        //   if (!isFinite(relaxSub)) relaxSub = 4;

          // Physical constraints: all stiffnesses, dt and bond length must be positive
          var EPS_K   = 1e-6;
          var EPS_DT  = 1e-5;
          var EPS_LEN = 1e-4;
          if (kLat <= 0.0)   kLat   = EPS_K;
          if (kRad <= 0.0)   kRad   = EPS_K;
          if (RTip <= 0.0)   RTip   = EPS_LEN;
          if (dt   <= 0.0)   dt     = EPS_DT;
          if (relaxIt < 1)   relaxIt = 1;
          if (oscSteps < 1)  oscSteps = 1;
          if (oscSteps > 32) oscSteps = 32;
          if (dz <= 0.0)     dz = 0.01;
          if (oscAmp <= 0.0) oscAmp = oscSteps * dz * 0.5;
          if (preRelax < 0)  preRelax = 0;
          if (preRelax > 32) preRelax = 32;
          if (relaxSub < 1)  relaxSub = 1;
          if (relaxSub > 16) relaxSub = 16;

          // Keep Osc steps, dz, Amp mutually consistent based on the last edited field
          var active = document.activeElement ? document.activeElement.id : '';
          if (active === 'inpOscSteps' || active === 'inpDz') {
            // steps or dz changed -> recompute Amp = steps * dz
            oscAmp = oscSteps * dz;
            var ampInput = document.getElementById('inpOscAmp');
            if (ampInput) ampInput.value = oscAmp.toFixed(3);
          } else if (active === 'inpOscAmp') {
            // Amp changed -> recompute steps ≈ Amp/dz, then snap Amp back to steps*dz
            var estSteps = Math.round(oscAmp / dz);
            if (!(estSteps > 0)) estSteps = 1;
            if (estSteps > 32) estSteps = 32;
            oscSteps = estSteps;
            oscAmp   = oscSteps * dz;
            var stepsInput = document.getElementById('inpOscSteps');
            var ampInput2  = document.getElementById('inpOscAmp');
            if (stepsInput) stepsInput.value = oscSteps.toString();
            if (ampInput2)  ampInput2.value  = oscAmp.toFixed(3);
          }
          // Determine actual anchor Z from user-defined height above top-most atom
          var chkShiftZ   = document.getElementById('chkShiftZ');
          var shiftZOn    = chkShiftZ && chkShiftZ.checked;
          var zTop = 0.0;
          if (molBounds.hasData) {
            zTop = shiftZOn ? 0.0 : molBounds.maxZ;
          }
          uniforms.uZPlane.value = zTop + z;
          uniforms.uScale.value  = scale;

          // Center: either molecule center + user offsets, or absolute user coordinates
          var centerX = cxUser;
          var centerY = cyUser;
          var chkCenterXY = document.getElementById('chkCenterXY');
          var centerOn    = chkCenterXY && chkCenterXY.checked;
          if (centerOn && molBounds.hasData) {
            var cxMol = 0.5 * (molBounds.minX + molBounds.maxX);
            var cyMol = 0.5 * (molBounds.minY + molBounds.maxY);
            centerX = cxMol + cxUser;
            centerY = cyMol + cyUser;
          }
          uniforms.uCenter.value.set(centerX, centerY);
          uniforms.uContrast.value = contrast;
          uniforms.uGridPeriod.value = (isFinite(gridPer) && gridPer > 0.0) ? gridPer : 1.0;
          // Tip multipoles (pass-through; electrostatics computed in shader)
          uniforms.uTipQ.value   = isFinite(tipQ)   ? tipQ   : 0.0;
          uniforms.uTipPz.value  = isFinite(tipPz)  ? tipPz  : 0.0;
          uniforms.uTipQzz.value = isFinite(tipQzz) ? tipQzz : 0.0;
          uniforms.uKLat.value       = kLat / 16.02176634; // convert from N/m to eV/Å^2
          uniforms.uKRad.value       = kRad / 16.02176634; // convert from N/m to eV/Å^2
          uniforms.uRtip.value       = RTip;
          uniforms.uRelaxIters.value = relaxIt;
          uniforms.uDt.value         = dt;
          uniforms.uAlgo.value       = algo;
          uniforms.uRenderMode.value = renderM;
          uniforms.uF2Conv.value     = f2conv;
          uniforms.uOscSteps.value   = oscSteps;
          uniforms.uDz.value         = dz;
          uniforms.uOscAmp.value     = oscAmp;
          uniforms.uPreRelax.value   = preRelax;
          uniforms.uRelaxSub.value   = relaxSub;
          // Recompute Giessibl weights
          var weights = calculateGiessiblWeights(oscSteps, dz);
          var wArr = uniforms.uWeights.value;
          wArr.fill(0.0);
          for (var wi = 0; wi < oscSteps && wi < wArr.length; wi++) {
            wArr[wi] = weights[wi];
          }
          setStatus('Updated view parameters');
          renderOnce();
        }

        // Giessibl weights as in getDfWeight
        function calculateGiessiblWeights(nSteps, dz) {
          if (!(nSteps > 1)) return [];
          var x = [];
          for (var i = 0; i <= nSteps; i++) {
            x.push(-1 + 2 * (i / nSteps)); // bottom -> top
          }
          var y = x.map(function (v) { var vv = 1 - v*v; return (vv > 0) ? Math.sqrt(vv) : 0.0; });
          var dy = [];
          for (var i = 0; i < nSteps; i++) {
            dy.push((y[i+1] - y[i]) / (dz * nSteps));
          }
          var fpi = Math.pow(nSteps - 2, 2);
          var prefactor = -1 * (1 + fpi * (2/Math.PI)) / (fpi + 1);
          var weights = [];
          for (var i = 0; i < nSteps; i++) {
            weights.push(dy[nSteps - 1 - i] * prefactor); // reverse: top->bottom
          }
          return weights;
        }

        // Button still available for manual trigger
        document.getElementById('btnUpdateView').addEventListener('click', updateViewFromInputs);

        // Auto-update when basic view parameter inputs change (if enabled)
        ['inpZ', 'inpScale', 'inpCX', 'inpCY', 'inpContrast', 'inpGridPeriod', 'selRenderMode', 'inpKLat', 'inpKRad', 'inpRTip', 'inpRelaxIters', 'inpDt', 'inpAlgo', 'inpF2Conv', 'inpOscSteps', 'inpDz', 'inpOscAmp', 'inpPreRelax', 'inpRelaxSub']
          .forEach(function (id) {
            var el = document.getElementById(id);
            if (!el) return;
            el.addEventListener('input', function () {
              if (autoUpdate) {
                updateViewFromInputs();
              }
            });
          });

        // Enable wheel increment/decrement for all numeric inputs (no need to maintain an ID list)
        Array.prototype.forEach.call(document.querySelectorAll('input[type="number"]'), function (el) {
          // Attach once per element
          el.addEventListener('wheel', function (ev) {
            ev.preventDefault();
            var step = parseFloat(el.step) || 1.0;
            var v    = parseFloat(el.value) || 0.0;
            var dir  = (ev.deltaY > 0) ? -1.0 : 1.0; // wheel up -> increase
            el.value = (v + dir * step).toString();
            // Trigger the same listeners as manual edits (some inputs need applyXYZ, others only updateViewFromInputs)
            el.dispatchEvent(new Event('input', { bubbles: true }));
            el.dispatchEvent(new Event('change', { bubbles: true }));
          }, { passive: false });
        });

        // Auto-update REQK when probe parameters change
        ['inpProbeQ', 'inpProbeR', 'inpProbeE', 'inpTipPz', 'inpTipQzz'].forEach(function (id) {
          var el = document.getElementById(id);
          if (!el) return;
          el.addEventListener('input', function () {
            if (autoUpdate) {
              applyXYZ(document.getElementById('txtXYZ').value);
              updateViewFromInputs();
            }
          });
        });
        // Auto-apply XYZ text edits
        var txtXYZ = document.getElementById('txtXYZ');
        if (txtXYZ) {
          txtXYZ.addEventListener('input', function () {
            if (autoUpdate) {
              applyXYZ(txtXYZ.value);
              updateViewFromInputs();
            }
          });
        }

        // Checkboxes to control auto-update and animation
        var chkAutoUpdate = document.getElementById('chkAutoUpdate');
        var chkAnimate    = document.getElementById('chkAnimate');
        var chkShowAtoms  = document.getElementById('chkShowAtoms');
        var selAtomLabel  = document.getElementById('selAtomLabel');
        var chkCenterXY   = document.getElementById('chkCenterXY');
        var chkShiftZ     = document.getElementById('chkShiftZ');
        var selRenderMode = document.getElementById('selRenderMode');

        function forceRecomputeFromUI() {
          // Called on checkbox/select changes; keep behavior simple & explicit.
          applyXYZ(document.getElementById('txtXYZ').value);
          updateViewFromInputs();
        }

        function forceOverlayRedraw() {
          // When only overlay options change we don't need shader recompute.
          drawOverlayAtoms();
        }

        if (chkAutoUpdate) {
          chkAutoUpdate.addEventListener('change', function () {
            autoUpdate = !!chkAutoUpdate.checked;
            console.log('autoUpdate =', autoUpdate);
          });
        }
        if (chkAnimate) {
          chkAnimate.addEventListener('change', function () {
            animateEnabled = !!chkAnimate.checked;
            console.log('animateEnabled =', animateEnabled);
            if (animateEnabled) {
              // Start animation loop
              animate();
            }
          });
        }

        // Ensure select/checkbox changes actually trigger update/redraw
        if (selRenderMode) selRenderMode.addEventListener('change', function () { if (autoUpdate) updateViewFromInputs(); else renderOnce(); });
        if (chkCenterXY)   chkCenterXY.addEventListener('change', function () { if (autoUpdate) updateViewFromInputs(); else renderOnce(); });
        if (chkShiftZ)     chkShiftZ.addEventListener('change', function () { if (autoUpdate) forceRecomputeFromUI(); else renderOnce(); });
        if (chkShowAtoms)  chkShowAtoms.addEventListener('change', forceOverlayRedraw);
        if (selAtomLabel)  selAtomLabel.addEventListener('change', forceOverlayRedraw);

      }

      function onWindowResize() {
        var container = document.getElementById('container');
        if (!renderer) return;
        renderer.setSize(container.clientWidth, container.clientHeight);
        uniforms.uResolution.value.set(renderer.domElement.width, renderer.domElement.height);
        if (overlayCanvas) {
          overlayCanvas.width  = renderer.domElement.width;
          overlayCanvas.height = renderer.domElement.height;
        }
      }

      function drawOverlayAtoms() {
        if (!overlayCtx || !overlayCanvas) return;
        var chk = document.getElementById('chkShowAtoms');
        if (!(chk && chk.checked)) {
          overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
          return;
        }
        var W = overlayCanvas.width;
        var H = overlayCanvas.height;
        overlayCtx.clearRect(0, 0, W, H);
        if (!atomsJS || atomsJS.length === 0) return;

        var cx = uniforms.uCenter.value.x;
        var cy = uniforms.uCenter.value.y;
        var scale = uniforms.uScale.value;

        var selLabel = document.getElementById('selAtomLabel');
        var labelMode = parseInt((selLabel && selLabel.value) ? selLabel.value : '0', 10) || 0;

        function colorForSym(sym) {
          var it = elementLJ ? elementLJ[sym] : null;
          if (it && it.color) {
            return 'rgba(' + parseInt(it.color.substr(1,2),16) + ',' + parseInt(it.color.substr(3,2),16) + ',' + parseInt(it.color.substr(5,2),16) + ',0.9)';
          }
          if (sym === 'Co') return 'rgba(255,140,0,0.9)';
          return 'rgba(255,255,0,0.9)';
        }

        overlayCtx.lineWidth = 1;
        if (labelMode !== 0) {
          overlayCtx.font = '10px "Segoe UI", "Helvetica Neue", Arial, sans-serif';
          overlayCtx.textBaseline = 'middle';
        }
        for (var i = 0; i < atomsJS.length; i++) {
          var a = atomsJS[i];
          // shader mapping: uv = (frag/res)*2-1; posXY = center + uv*scale
          var uvx = (a.x - cx) / scale;
          var uvy = (a.y - cy) / scale;
          var px = (uvx * 0.5 + 0.5) * W;
          // WebGL frag coords have origin at bottom-left; 2D canvas has origin at top-left
          var py = (1.0 - (uvy * 0.5 + 0.5)) * H;
          // outside viewport -> skip
          if (px < -20 || px > W + 20 || py < -20 || py > H + 20) continue;
          overlayCtx.beginPath();
          overlayCtx.fillStyle = colorForSym(a.sym);
          overlayCtx.strokeStyle = 'rgba(0,0,0,0.6)';
          overlayCtx.arc(px, py, 3.0, 0, Math.PI * 2);
          overlayCtx.fill();
          overlayCtx.stroke();

          if (labelMode !== 0) {
            var txt = '';
            if (labelMode === 1) {
              txt = (a.i !== undefined && a.i !== null) ? String(a.i) : String(i);
            } else if (labelMode === 2) {
              txt = a.sym;
            } else if (labelMode === 3) {
              txt = (a.q !== undefined && a.q !== null) ? Number(a.q).toFixed(2) : '0.00';
            } else if (labelMode === 4) {
              txt = (a.z !== undefined && a.z !== null) ? Number(a.z).toFixed(2) : '0.00';
            }
            if (txt) {
              var tx = px + 5.0;
              var ty = py;
              overlayCtx.fillStyle = 'rgba(0,0,0,0.6)';
              overlayCtx.fillText(txt, tx, ty);
            }
          }
        }
      }

      // Render a single frame (used both for on-demand updates and animation)
      function renderOnce() {
        if (!(renderer && scene && camera)) return;
        console.log('renderOnce: rendering frame');
        renderer.render(scene, camera);
        drawOverlayAtoms();
      }

      function animate() {
        if (!animateEnabled) return; // stop loop when animation is disabled
        requestAnimationFrame(animate);
        frameCounter++;
        if ((frameCounter % 60) === 0) {
          console.log('animate loop frame', frameCounter, 'animateEnabled =', animateEnabled);
        }
        renderOnce();
      }

      function setStatus(msg) {
        document.getElementById('status').textContent = msg;
      }

      function loadXYZ(url) {
        fetch(url)
          .then(function (r) { return r.text(); })
          .then(function (txt) {
            document.getElementById('txtXYZ').value = txt;
            applyXYZ(txt);
            setStatus('Loaded ' + url);
          })
          .catch(function (e) {
            setStatus('Error loading ' + url + ': ' + e);
          });
      }

      function applyXYZ(text) {
        var lines = text.split(/\r?\n/).filter(function (l) { return l.trim().length > 0; });
        if (lines.length < 3) {
          setStatus('XYZ seems too short');
          console.log('applyXYZ: too short, lines.length =', lines.length);
          return;
        }
        var natoms = parseInt(lines[0]);
        if (!(natoms > 0)) {
          setStatus('XYZ header natoms is not > 0');
          console.log('applyXYZ: invalid natoms from header, lines[0]=', lines[0]);
          return;
        }

        // Support both XYZ formats:
        // 1) With comment line:      N, comment, N atom lines  -> lines.length >= natoms+2, atoms start at index 2
        // 2) Without comment line:   N, N atom lines           -> lines.length >= natoms+1, atoms start at index 1
        var atomStartIndex = 2;
        if (lines.length < natoms + 2) {
          if (lines.length >= natoms + 1) {
            atomStartIndex = 1;
          } else {
            setStatus('XYZ header inconsistent with number of lines');
            console.log('applyXYZ: inconsistent lengths, natoms =', natoms, 'lines.length =', lines.length);
            return;
          }
        }
        var atoms = [];
        var atomsRaw = [];
        var minX =  1e9, minY =  1e9, minZ =  1e9;
        var maxX = -1e9, maxY = -1e9, maxZ = -1e9;
        for (var i = 0; i < natoms; i++) {
          var parts = lines[atomStartIndex + i].trim().split(/\s+/);
          if (parts.length < 4) continue;
          var sym = parts[0];
          var x = parseFloat(parts[1]);
          var y = parseFloat(parts[2]);
          var z = parseFloat(parts[3]);
          // atomic charge if provided (take first parsable token beyond xyz)
          var q = 0.0;
          for (var qi = 4; qi < parts.length; qi++) {
            var qtmp = parseFloat(parts[qi].replace(',', '.'));
            if (isFinite(qtmp)) { q = qtmp; break; }
          }
          atoms.push(new THREE.Vector4(x, y, z, q));
          atomsRaw.push({ i: i, sym: sym, x: x, y: y, z: z, q: q });
          if (x < minX) minX = x; if (x > maxX) maxX = x;
          if (y < minY) minY = y; if (y > maxY) maxY = y;
          if (z < minZ) minZ = z; if (z > maxZ) maxZ = z;
        }
        // Probe parameters from UI
        var qProbe = parseFloat(document.getElementById('inpProbeQ').value) || 0.05;
        var Rpp    = parseFloat(document.getElementById('inpProbeR').value) || 1.6612;   // O from atomtypes.ini
        var Epp    = parseFloat(document.getElementById('inpProbeE').value) || 0.009106; // O from atomtypes.ini

        // Build REQK per atom: (R0,E0,q_atom,K) using Lorentz-Berthelot mixing
        // Rij = Rpp + Rii, Eij = sqrt(Epp * Eii). Atom charge is passed through directly;
        // tip electrostatics (monopole/dipole/quadrupole) are applied in the shader.
        var REQK = [];
        var K_default   = 1.5;
        for (var j = 0; j < atoms.length; j++) {
          var partsj = lines[atomStartIndex + j].trim().split(/\s+/);
          var sym = partsj[0];
          var lj  = elementLJ[sym] || elementLJ['C'];
          var Rii = lj.R;
          var Eii = lj.E;
          var R0  = Rpp + Rii;
          var E0  = Math.sqrt(Math.max(Epp,0.0) * Math.max(Eii,0.0));
          var qj  = atoms[j].w;
          REQK.push(new THREE.Vector4(R0, E0, qj, K_default));
        }

        // GLSL uses fixed-size arrays uAtoms[256] and uREQK[256], so pad
        var maxAtoms = 256;
        uniforms.uNumAtoms.value = Math.min(atoms.length, maxAtoms);
        if (atoms.length > maxAtoms) {
          atoms.length = maxAtoms;
          REQK.length = maxAtoms;
        }
        // Padding defaults for REQK (used for off-screen dummy atoms)
        var R0_pad = 3.0;
        var E0_pad = 0.1;
        while (atoms.length < maxAtoms) {
          atoms.push(new THREE.Vector4(1e9, 1e9, 1e9, 0.0));
          REQK.push(new THREE.Vector4(R0_pad, E0_pad, 0.0, K_default));
        }
        uniforms.uAtoms.value = atoms;
        uniforms.uREQK.value  = REQK;

        if (uniforms.uNumAtoms.value > 0) {
          console.log('applyXYZ/REQK: uNumAtoms =', uniforms.uNumAtoms.value,
                      'atom0 xyzq =', atoms[0].x, atoms[0].y, atoms[0].z, atoms[0].w,
                      'REQK0 =', REQK[0].x, REQK[0].y, REQK[0].z, REQK[0].w);
        }

        // Store molecule bounds; optional Z-shift (top-most atom to z=0) is handled via checkbox
        if (uniforms.uNumAtoms.value > 0) {
          var chkShiftZ = document.getElementById('chkShiftZ');
          var shiftZOn  = chkShiftZ && chkShiftZ.checked;
          var zShift    = shiftZOn ? maxZ : 0.0;

          // Apply Z-shift if requested and recompute bounds in shifted coordinates
          if (shiftZOn) {
            minZ -= zShift;
            maxZ -= zShift;
            for (var ia = 0; ia < atoms.length; ia++) {
              atoms[ia].z -= zShift;
            }
            for (var ia = 0; ia < atomsRaw.length; ia++) {
              atomsRaw[ia].z -= zShift;
            }
          }

          molBounds.hasData = true;
          molBounds.minX = minX;
          molBounds.maxX = maxX;
          molBounds.minY = minY;
          molBounds.maxY = maxY;
          molBounds.minZ = minZ;
          molBounds.maxZ = maxZ;
        }

        // Update JS overlay atom list (only real atoms, not padded)
        atomsJS = atomsRaw;

        // Debug output
        if (uniforms.uNumAtoms.value > 0) {
          console.log('applyXYZ: uNumAtoms =', uniforms.uNumAtoms.value,
                      'first atom =', atoms[0].x, atoms[0].y, atoms[0].z,
                      'center =', uniforms.uCenter.value.x, uniforms.uCenter.value.y,
                      'zPlane =', uniforms.uZPlane.value, 'scale =', uniforms.uScale.value);
        } else {
          console.log('applyXYZ: no atoms parsed');
        }

        setStatus('Parsed ' + uniforms.uNumAtoms.value + ' atoms');
      }

      init();
    </script>
  </body>
</html>
